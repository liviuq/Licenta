\chapter{Implementarea soluției}

Prin parcurgerea acestui capitol, cititorul va avea o imagine de ansamblu asupra modului în care senzorii sunt integrați în aplicație, cum este realizată comunicarea cu serverul și care sunt aspectele legate de programarea și funcționalitatea aplicației mobile. Aceste informații sunt esențiale pentru a înțelege arhitectura (Figura 3.1) și funcționalitatea aplicației în cadrul sistemului smart home propus.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{arhitectura}
	\caption{Legătura dintre componentele soluției}
	\label{fig:arhitectura}
\end{figure}

INSERT C4 diagram

\section{Pagina principală}

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=1\linewidth]{1}
	\caption{Pagina principală}
	\label{fig:1}
\end{wrapfigure}

Primul punct de contact dintre un utilizator și acest proiect este aplicația de telefon (Figura 3.2). Odată lansată, va prezenta un splash screen, urmat de pagina principală. Aici se regăsesc toți senzorii conectați la sistem, împreună cu id-ul, valoarea cu timpul la care au fost înregistrate și locația din casă a senzorului. 

Aceștia sunt sortați după parametrul pe care îl colectează, fie detectarea mișcării, calcularea distanței, a temperaturii sau a umidității, lucru care se observă din titlurile situate deasupra fiecărui cartonaș. Aceste device-uri se numesc \emph{senzori statici}, care sunt folosiți doar pentru colectare de informații. Mai există alt tip de senzor numit \emph{dinamic} a cărui caracteristici seamănă cu a celor statici, singura diferență fiind posibilitatea de comunicare bidirecțională. În cazul acestui proiect, singurul senzor de acest tip va închide și deschide o lampă în circumstanțele prezentate la secțiunea proprie.

În partea de sus se află două butoane, unul de activare/ dezactivare a \emph{modului de securitate} alături de cel de refresh care preia cele mai recente valori ale senzorilor, fiecare având o secțiune dedicată funcționalității și a modului de utilizare.

Pe post de footer sunt alte două butoane care servesc pe post de notificări atunci când valoarea unui senzor scade sub o anumită limită, respectiv cel de informații personale ale creatorului licenței.

\subsection{Cărțile senzorilor}

Cărțile reprezintă principala sursă de informații pe care un utilizator o regăsește instant când accesează aplicația. Ele oferă date importante despre senzorul respectiv într-o formă ușor de înțeles și de citit rapid.

În prima parte putem observa numele de identificare a senzorului. Acesta îi este asignat manual atunci când placa Arduino este programată și trebuie neapărat să fie unic în toată rețeaua. 

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.5\textwidth]{3}
	\caption{Valorile unui modul}
	\label{fig:3}
\end{wrapfigure}

În cazul în care există multiple dispozitive cu același ID, stația de bază va crede că a primit două pachete de la același senzor, când defapt au fost trimise de către senzori care, foarte probabil, sunt programați să colecteze date diferite și astfel vor apărea discrepanțe vizibile între valorile trimise.

După, putem observa valoarea primită de către aplicație la data și ora respectivă. Odată ce este reîmprospătată pagina, dacă device-ul este conectat la rețea, telefonul va primi cea mai recentă măsurătoare din baza de date care primește informații noi odată la două secunde.

Și nu în ultimul rând, apare și locul fizic exact al senzorului, el fiind setat de către utilizator în aplicație. Inițial, acest câmp nu este vizibil deoarece senzorii nu au atașați un loc stabil, atașarea și schimbarea lui fiind făcute de către utilizator.

Când vine vorba despre device-urile dinamice, au o interfață asemănătoare, singura diferență fiind câmpul de adresă care deține IP-ul local al senzorului.

Atunci când acest widget este apăsat, utilizatorul va intra pe pagina senzorului respectiv, detaliile căreia vor fi prezentate ADAUGA REFERINTA.

\subsection{Locația senzorului}

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.4\textwidth]{2}
	\caption{Pop-up pentru locație}
	\label{fig:2}
\end{wrapfigure}

Cu un suport larg de diferite gesturi cu ajutorul clasei GestureDetector din Flutter, avem acces la o suită de detectări a mișcărilor degetetului care pot executa anumite funcții. În cazul aplicației, odată ce se ține apăsat pe un cartonaș, va apărea un dialog în care putem introduce locația fizică a senzorului.

Aceasta este salvată în memoria locală a telefonului cu ajutorul bibliotecii de gestionare a bazelor de date NoSQL (non-relaționale). Am ales biblioteca respectivă datorită performanței ridicate, simplitatea oferită și compatibilitatea cross-platform care este critică deoarece aplicația aceasta poate fi compilată pentru majoritatea device-urilor populare. 
\break

\subsection{Modul de securitate} 

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.45\textwidth]{4}
	\caption{Interfață secure mode}
	\label{fig:4}
\end{wrapfigure}

În ultimii ani, numărul de furturi din locuințe se află pe un trend descrescător, conform informațiilor oferite de către Inspectoratul General al Poliției Române (\textbf{IGPR}). Așadar, în anul 2019 au fost înregistrate 22341 de furturi, iar în 2020 infracțiunile au ajuns la 18060, cu 19\% mai puține față de anul precedent. Chiar și în aceste circumstanțe, acest număr se datorează mentalității defensive în continuă dezvoltare și a sistemelor de alarmă care devin tot mai sofisticate. Am decis că introducerea unei astfel de abilități va contribui pozitiv la securizarea locuinței în care sistemul este instalat.

Modul de securitate se încadrează la categoria de bariere \emph{psihice} deoarece \emph{"descurajează infractorii sau detectează în faza incipientă o tentativă de pătrundere prin efracţie (sisteme de securitate perimetrală, antiefracţie, control al accesului sau sisteme de supraveghere şi înregistrare video)"}\footnote{\url{https://www.politiaromana.ro/ro/prevenire/furturi-din-locuinte}.}

Este recomandat ca, atunci când utilizatorul pleacă din incinta în care este instalată soluția smart home, să activeze modul de securitate. Fiecărui senzor îi poate fi atribuit o limită astfel încât orice valoare preluată  care scade sub acest prag (numit și \emph{Threshold}), va apărea sub forma unei notificări pe pagina de \emph{Logs}.

După ce este activat, utilizatorului îi este făcut prezent acest fapt prin schimbarea culorii de background. Valoarea acestui buton este salvată în baza de date Hive, împreună cu data și ora la care a fost schimbată. Aceasta din urmă va fi folosită la filtrarea alarmelor false.

Senzorii dinamici pot fi configurați astfel încât să se folosească de această valoare și din acest motiv, la fiecare schimbare a acestui buton, valoarea va fi postată pe ruta \textbf{https://andr3w.ddns.net/secure}, urmând să fie disponibilă tuturor device-urilor pentru a o putea citi.

\subsection{Butonul de refresh}

Funcționalitatea sa este intuitivă, întrucât apăsarea lui rezultă în re-împrospătarea valorilor din aplicație cu cele mai recente citiri ale tuturor senzorilor sistemului. Deoarece tot backend-ul este hostat pe un procesor cu un singur nucleu, am decis să implementez o metodă de \emph{caching} a datelor pentru sesiunea curentă. În acest mod salvăm serverul de la multe request-uri și economisim datele mobile.

Una din limitările sistemului este că informațiile afișate nu sunt actualizate constant. Acest lucru duce la discrepanțe între valorile pe care utilizatorul le vede și cele pe care senzorii le trimit. Vom vorbi despre aceasta în capitolul dedicat viziunii pe viitor.

\break

\section{Pagina senzorului static}

\begin{wrapfigure}{r}{0.3\textwidth}
	\includegraphics[width=0.4\textwidth]{5}
	\caption{Date avansate despre senzorul 01}
	\label{fig:5}
\end{wrapfigure}

Pe această rută se află informații și setări care contribuie la sensul de Smart home: componente ce lucrează împreună pentru a aduce utilizatorului un aport esențial de securitate.

AppBar-ul este populat cu un buton de setare a unei limite, valoare despre care am vorbit în secțiunea aceasta(ADAUGA SECUTIUNE MOD DE DECURITAET). Odată ce \emph{threshold} este setat (Figura 3.7.b), va fi salvată în baza de date locală, astfel ea persistând chiar și când restartăm aplicația. Ca să fie vizibilă utilizatorului, pe graficul de mai jos se va trasa o linie roșie (care nu există dacă nu avem o limită). Ca utilizare, limita va fi folosită la notificările de pe pagina de \emph{Logs} pentru a determina dacă o înregistrare trebuie arătată utilizatorului în caz că valoarea ei scade sub limita asignată.

În prim plan se află graficul care afișează evoluția ultimelor N înregistrări ale senzorului respectiv în funcție de data la care au fost colectate individual. Fiindcă sunt foarte multe puncte afișate, nu am putut include vizual și valorile lor, dar, utilizatorul o poate vedea, împreună cu data aferentă dacă apasă pe oricare punct (Figura 3.7.a). Pentru construcția sa, am decis să folosesc librăria \textbf{fl\_chart} datorită popularității și a documentației excelente. Este un grafic fluid deoarece odată ce se modifică valorile afișate, motorul fl\_chart creează o animație de tranziție de la informațiile vechi la cele noi.

Dedesubtul figurii apare un slider care setează numărul de puncte extrase de la server. A existat o problemă aici care îmi făcea un API call la fiecare schimbare de valoare, adică dacă de la 39 de puncte doresc să îmi afișeze 200, va face 200-39 = 161 request-uri către backend. Remediul a fost ca reîmprosătarea să fie făcută în funcția \textbf{onChangeEnd} care îmi dă libertatea să aleg orice valoare din interval atât timp cât degetul încă face contact cu ecranul. Atunci când am luat degetul de pe ecran, Flutter va face request-ul, evitând astfel un semi \emph{Denial of Service} pentru server.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.45\textwidth}
		\includegraphics[width=\textwidth]{6}
		\caption{Grafic}
		\label{fig:6}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\includegraphics[width=\textwidth]{7}
		\caption{Dialog limită}
		\label{fig:7}
	\end{subfigure}
	\caption{}
	\label{fig:all3}
\end{figure}

\section{Pagina senzorului dinamic}

\begin{wrapfigure}{r}{0.3\textwidth}
	\includegraphics[width=0.4\textwidth]{8}
	\caption{Informații și rutele senzorului dinamic}
	\label{fig:8}
\end{wrapfigure}

Modulele dinamice sunt destul de diferite față de cele statice, întrucât se conectează direct la rețeaua locală de Wi-Fi (fiindu-le asignat o adresă IP) și pot primi sau trimite comenzi la server sau la alte module dinamice. M-am decis să adaug acest tip de senzori datorită recomandării îndrumătorului licenței, domnul profesor Vidrașcu, o adiție ce se pliază perfect pe subiectul abordat în această teză: o soluție smart home.

După cum se poate observa, avem afișate datele despre senzor într-o manieră similară cu cea de la cei statici, diferența fiind IP-ul. Senzorii dinamici pot fi controlați de către utilizator și, în acest caz, este prin intermediul butoanelor ce apelează \emph{endpoint-urile} hostate pe ESP8266. Un endpoint reprezintă o locație specifică către care se pot face cereri HTTP (GET, POST, PUT, DELETE) pentru a accesa și manipula resursele unui serviciu. Serverul de pe ESP8266 își publică endpoint-urile la stația de bază care arată astfel: \textbf{http://192.168.0.101/turnOffLamp}.

Fiecare rută pe care o apelăm va instrui senzorul să execute diferite funcționalități care pot fi deduse din numele afișat pe buton.

\textbf{IntruderLampAlert} desemnează cum reacționează acest modul atunci când modul de securitate este activat și senzorul de mișcare emite un ”1” logic.

\section{Pagina de Logs}

Fiecare anomalie din sistem (orice senzor ce înregistrează o valoare care a scăzut sub limita impusă) va crea o notificare pe care utilizatorul o poate verifica în secțiunea de \textbf{Logs}. Aceasta poate fi accesată din bara de footer al meniului principal.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.45\textwidth}
		\includegraphics[width=\textwidth]{11}
		\caption{Valori ce vor genera erori}
		\label{fig:11}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\includegraphics[width=\textwidth]{12}
		\caption{Pagina de logging}
		\label{fig:12}
	\end{subfigure}
	\caption{}
	\label{fig:all5}
\end{figure}

Inițial, aplicația nu generează notificări dacă un senzor a înregistrat o abatere de la normal atunci când \textbf{Secure Mode} nu este activat deoarece se presupune că utilizatorul nu a plecat încă de acasă. Activarea modului de securitate va cauza afișarea anomaliilor pe ecran.

Din figura 3.9.a se pot extrage anumite informații astfel: există trei puncte care se află sub bariera setată cu ajutorul butonului \textbf{Set threshold}, ceea ce înseamnă că utilizatorul și-a părăsit apartamentul, dar încă există activitate. 

Aplicația va prelua ultimele înregistrări a fiecărui senzor pe care le compară cu limita (stocată în baza de date locală) și afișează cartonașele corespunzător. Se poate observa în figura 3.9.b. că ultima alertă este cea din figura anterioară.

\break

\section{Pagina de genereare de rapoarte}

În cazul în care utilizatorul este o victimă a unui jaf sau unei intruziuni în casă, este important să acționeze în mod corespunzător. Primul pas este să își asigure siguranța personală și să sune imediat la serviciile de urgență sau la poliție, încercând să nu intre în contact cu posibilii infractori sau să manipuleze evidențele rămase la fața locului, pentru a nu distruge potențiale probe. După anunțarea autorităților, trebuie făcută o inventariere a obiectelor pierdute și să fie extrase cât mai multe informații din ziua respectivă legate de incident.

Aplicația din această soluție ajută utlizatorul în cazul unui astfel de eveniment prin colectarea tuturor datelor senzorilor din casă, expunându-le în formă de PDF gata să fie oferite autorităților. Trebuie menționat faptul că senzorii au fost plasați specific în holul de la intrarea în apartamentul meu, pozitionați astfel încât orice persoană care intră va modifica starea modulelor.

Interfața (Figura 3.9.a) este alcătuită din cele două câmpuri ce permit introducerea timpului de început și cel de sfârșit. Acestea vor fi folosite de către server pentru a filtra toate înregistrările senzorilor, luându-le doar pe cele ce se încadrează în intervalul specificat. Cele două valori trebuie neapărat setate, întrucât butonul de \textbf{Generate report} nu va funcționa fiindcă nu știe unul din capetele intervalului sau chiar ambele. Odată apăsat, va trimite un POST request la stația de bază care îi va răspunde cu datele aferente. Utilizatorul este notificat de terminarea procesului printr-un pop-up în josul ecranului ce oferă și folderul în care a fost salvat.

Cu ajutorul librăriei \textbf{pdf} din cadrul SDK-ului Flutter, am reușit generarea documentului (Figura 3.9.b). Pe post de header, am specificat intervalul din care au fost extrase informațiile senzorilor și data la care a fost creat acest document. Footer-ul conține numele aplicației și deținătorul drepturilor licenței. În centrul atenției este un tabel ce conține, în ordine, numărul curent al înregistrării, adresa, data, ID-ul, tipul și valoarea senzorului. Acesta este extins pe multiple foi, cifra din partea de jos al ecranului desemnând numărul curent al paginii. Pentru raportul acesta avem un număr de 300 de înregistrări preluate în decursul a 5 minute. Stația de bază este responsabilă să recepționeze și să citească pachetele trimise de toți senzorii, lucru care devine destul de greu atunci când fiecare device transmite în aceeași secundă după cum se observă în PDF. Datorită librăriei \textbf{RF24Network} despre care vom vorbi în secțiunea senzorilor statici, toate pachetele vor fi decodate cu succes.

Datele acestui document sunt valoroase și pot ajuta foarte mult investigatorii, crescând astfel șansele de a prinde intrușii. Asigurând proprietarii ce folosesc acest sistem cu un raport plin de informații, soluția de smart home propusă joacă un rol important în creșterea securității utilizatorului.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.43\textwidth}
		\centering
		\includegraphics[width=\textwidth]{9}
		\caption{Interfața paginii}
		\label{fig:9}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.43\textwidth}
		\centering
		\includegraphics[width=\textwidth]{10}
		\caption{PDF-ul generat}
		\label{fig:10}
	\end{subfigure}
	\caption{}
	\label{fig:all4}
\end{figure}
\break

\section{Senzori statici}

Acest tip de device-uri stă la baza metodei de coletare a informațiilor despre casa respectivă și cea de generare a unui raport cu toate valorile din baza de date în intervalul cerut.

Figura 3.3.a ne prezintă cum a fost creat un senzor static: un Arduino Nano care este cablat la senzorul de detectare a mișcării și modulul de transmitere a datelor. 

Senzorul are 3 pini care trebuie conectați la placa de dezvoltare: Ground (împământare), Vcc (+5V) și Out. Ultimul pin emite un 0 logic dacă nu a detectat niciun obiect și 1 logic dacă a detectat o persoană sau un animal. Acest lucru este posibil datorită faptului că este emisă căldură în formă de radiații infra-roșii care alimentează componenta \emph{piroelectrică} (Figura 3.3.b) amplasată dedesubtul unei lentile Fresnel ce ajută focusarea acestor raze pe lentila senzorului. Modulul are încorporat două potențiometre: unul pentru reglarea razei de acțiune (până în 5 metri), iar celălalt pentru reglarea timpului de schimbare a valorii detectate (între 0.3 - 300 secunde). 

Odată alimentat la 5V, microcontroller-ul începe colectarea de date odată la două secunde. După ce acest interval a trecut, va fi creat un pachet ce conține ID-ul și tipul modulului, valoarea și data la care a fost făcută măsurătoarea. 

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.85\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{static}
		\caption{Arduino Nano + senzor de mișcare + modul transmisie}
		\label{fig:static}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.8\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{pir}
		\caption{Componenta piroelectrică}
		\label{fig:pir}
	\end{subfigure}
	\caption{}
	\label{fig:all2}
\end{figure}
\break

Transmiterea și primirea acestor pachete va fi detaliată în secțiunea despre placa NRF24L01 unde vom vorbi de banda 2.4GHz, structura unui pachet de date și RF24Network. 

\section{Senzori dinamici}

Senzorii dinamici dețin o complexitate mai ridicată față de tipul anterior prezentat datorită faptului că pot trimite și primi date simultan de la server, făcându-i să pară că folosesc o conexiune \emph{full duplex}. Din cauza faptului că legătura dintre server și senzor se face prin intermediul protocolului Wifi, înseamnă că această legătură este mai degrabă \emph{half duplex}, schimbul de date realizându-se prin alternarea transmițătorului și receptorului, iar dispozitivele trebuie să respecte un anumit protocol de acces pentru evitarea coliziunilor și interferențelor cu alte dispozitive. CITAT

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{dinamic}
	\caption{ESP8266 cu modul releu alimentat la 220V}
	\label{fig:dinamic}
\end{figure}

\section{Modul debug}

\textbf{Network\_rx.py} reprezintă modul de debug, fiind o unealtă care ajută utilizatorul la momentul instalării senzorilor sau atunci când unii nu mai funcționează corespunzător.

În timpul execuției, acesta afișează în consolă (Figura \ref{fig:13}) toate pachetele pe care le primește în timp real. Acest lucru este util deoarece permite utilizatorului să confirme că senzorii funcționează corect și trimit datele corespunzătoare. Problemele de comunicare sunt depistate din timp, de obicei acestea se rezolvă cu o restartare a modulelor.

Fiecare linie deține datele unei înregistrări: \textbf{payload len} reprezintă lungimea în octeți a pachetului, \textbf{sensor type} e tipul senzorului (distanță, temperatură, mișcare), \textbf{value} conține valoarea citită de device, iar \textbf{header} are date precum id-ul pachetului, emițătorul și receptorul, care în cazul acesta este stația de bază la adresa \textbf{00}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{13}
	\caption{Detaliile senzorilor conectați la stația de bază}
	\label{fig:13}
\end{figure}

Este important ca user-ul să aibă instalate toate librăriile de care acest script depinde, lucru despre care vom intra în detaliu la secțiunea backendului. Fiind un script scris în python aflat în folderul \textbf{debug\_scripts}, este executat prin introducerea comenzii \textbf{python3 Licenta/flask/debug\_scripts/network\_rx.py}. Fiindcă rulează la infinit, se poate ieși din el apăsând \textbf{Ctrl + C} sau urmând instrucțiunile de aici. \footnote{\url{https://github.com/hakluke/how-to-exit-vim\#the-hardware-way}.}

\newpage

\section{Componenta de backend}

Backend-ul reprezintă partea aplicației responsabilă de logică și funcționalitate. În contextul acestei licențe, am decis să folosesc limbajul \textbf{Python} versiunea 3.10 cu microframework-ul \textbf{Flask} către care sunt trimise pachetele de la \textbf{gunicorn} și \textbf{nginx}.

\subsection{Raspberry Pi}

Pentru o productivitate crescută, am ales să instalez sistemul de operare \emph{Raspberry Pi OS Lite} deoarece este rapid, lucru datorat lipsei unei interfețe grafice și a programelor pre-instalate. Instalarea a fost foarte ușoară, urmând instrucțiunile din documentația lor\footnote{\url{https://www.raspberrypi.com/documentation/}}.

Comunicarea cu placa a fost făcută doar prin \textbf{SSH} care a fost deschis din setările router-ului. Fiindcă această conexiune va fi publică, am instalat programul \textbf{ufw} (\emph{uncomplicated firewall}) ce mi-a ușurat securizarea host-ului, fiind o unealtă ce înlocuiește setările complicate ale \textbf{iptables}\footnote{\url{https://wiki.archlinux.org/title/iptables}.} cu comenzi simple: \emph{sudo ufw allow 22}. Astfel am limitat numărul de conexiuni la portul 22 și am permis accesul la portul 443, acestea fiind singurele  căi de acces.

Criptarea traficului e realizată direct de către nginx, specificând locația certificatului și a cheii private cu ajutorul comenzilor \emph{ssl\_certificate} și \emph{ssl\_certificate\_key}. Am decis să îmi semnez propriul \textbf{certificat SSL} (Secure sockets layer) cu \textbf{openssl} executând comanda \emph{openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365}. 

\subsection{DNS dinamic}

Provider-ul de internet asignează dinamic adresele IP utilizatorilor conectați, motiv pentru care după o pană de curent, de obicei se resetează această adresă. Pentru a rezolva această problemă, am utilizat serviciul gratuit de \textbf{Dynamic DNS}\footnote{\url{https://www.noip.com/support/knowledgebase/geek-terms}} al companiei \textbf{No-IP}\footnote{\url{https://www.noip.com/}}. Setările au fost realizare direct pe router-ul personal, un \textbf{TP-Link WR740N}. Odată configurat, rețeaua locală poate fi accesată de la adresa \url{https://andr3w.ddns.net}.

\subsection{REST API}

Un \textbf{API} (\textbf{Application programming interface}) este un mecanism care permite unui serviciu să acceseze resursels unui alt serviciu. REST API se bazează pe principii precum utilizarea verbelor HTTP (GET, PUT, POST, DELETE) pentru transmiterea și manipularea datelor într-un format standardizat (XML, JSON), împreună cu ajutorul \textbf{URI} (uniform resource identifier) pentru specificarea resursei asupra cărei operațiile vor fi executate. Am creat astfel o arhitectură REST pentru a servi diferite informații către aplicația de mobil, afișându-le într-o manieră ușor de înțeles. \footnote{\url{https://www.ibm.com/topics/rest-apis}.}

\subsection{SQLAlchemy}

\textbf{SQLAlchemy} este o colecție de unelte ce ajută programatorul să acceseze și manipuleze baze de date SQL în limbajul Python. Se pot scrie query-uri în formă de \emph{string-uri} (raw sql) sau înlănțuind obiecte din python într-o manieră \textbf{ORM} (Object relational mapping)\footnote{\url{https://docs.sqlalchemy.org/en/20/orm/queryguide/index.html}.}. Motivele pentru care am folosit acest toolkit sunt simplicitatea creării interogărilor, rapiditarea codării și multitudinea tutorialelor valabile.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{14}
	\caption{Informațiile oferite de DB Browser for SQLite} \footnote{\url{https://sqlitebrowser.org/}.}
	\label{fig:14}
\end{figure}

Există două tabele definite în \textbf{/flask/application/models.py}: \textbf{Sensor} și \textbf{AdvancedSensor}, ambele stocând date precum id-ul, numele, valoarea și data la care a fost adăugată înregistrarea senzorului în baza de date.

\subsection{Serverul Flask}

Acesta rulează pe stația de bază (Raspberry Pi Zero W) pentru a satisface fiecare cerere a utilizatorului, fără a fi nevoit să își deschidă calculatorul personal pentru a putea interacționa cu dispozitivele sale. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.85\textwidth]{15}
	\caption{Consola serverului}
	\label{fig:15}
\end{figure}

Nginx este un \textbf{reverse proxy}\footnote{\url{https://www.nginx.com/resources/glossary/reverse-proxy-server/}.} care se află între client și backend. Acesta primește cererile din exterior pe care le redirecționează serverului de gunicorn după setările din figura \ref{fig:16}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.85\textwidth]{16}
	\caption{Configurare Nginx}
	\label{fig:16}
\end{figure}

Prima componentă numită \emph{server} interceptează fiecare cerere HTTP pe care o redirecționează la ruta de HTTPS asignată portului 443, returnând astfel codul 301 ce notifică utilizatorul că a fost redirectat de la ruta \textbf{http://} la cea de \textbf{https://}.

A doua componentă asultă la portul 443 (HTTPS) și, datorită blocului \textbf{location /}, orice cerere va fi redirecționată către serverul Flask, fiind configurat a primi request-uri la portul 8000. Trebuie menționat faptul că ambele aplicații rulează pe același host, ceea ce face posibilă trimiterea cu succes către adresa de \emph{loopback}\footnote{\url{https://study-ccna.com/loopback-interface-loopback-address/}}. Această utilizare este ideală deoarece ne aflăm la o scară de nivel de proiect personal. Pentru uz în producție se recomandă folosirea unui proxy server\footnote{\url{https://browserjet.com/blog/advantages-and-disadvantages-of-a-proxy-server}} pe un computer separat.

