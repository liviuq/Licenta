\chapter{Implementarea soluției}

Prin parcurgerea acestui capitol, cititorul va avea o imagine de ansamblu asupra modului în care senzorii sunt integrați în aplicație, cum este realizată comunicarea cu serverul și care sunt aspectele legate de programarea și funcționalitatea aplicației mobile. Aceste informații sunt esențiale pentru a înțelege arhitectura (Figura 3.1) și funcționalitatea aplicației în cadrul sistemului smart home propus.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{arhitectura}
	\caption{Legătura dintre componentele soluției}
	\label{fig:arhitectura}
\end{figure}

INSERT C4 diagram

\section{Pagina principală}

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=1\linewidth]{1}
	\caption{Pagina principală}
	\label{fig:1}
\end{wrapfigure}

Primul punct de contact dintre un utilizator și acest proiect este aplicația de telefon (Figura 3.2). Odată lansată, va prezenta un splash screen, urmat de pagina principală. Aici se regăsesc toți senzorii conectați la sistem, împreună cu id-ul, valoarea cu timpul la care au fost înregistrate și locația din casă a senzorului. 

Aceștia sunt sortați după parametrul pe care îl colectează, fie detectarea mișcării, calcularea distanței, a temperaturii sau a umidității, lucru care se observă din titlurile situate deasupra fiecărui cartonaș. Aceste device-uri se numesc \emph{senzori statici}, care sunt folosiți doar pentru colectare de informații. Mai există alt tip de senzor numit \emph{dinamic} a cărui caracteristici seamănă cu a celor statici, singura diferență fiind posibilitatea de comunicare bidirecțională. În cazul acestui proiect, singurul senzor de acest tip va închide și deschide o lampă în circumstanțele prezentate la secțiunea proprie.

În partea de sus se află două butoane, unul de activare/ dezactivare a \emph{modului de securitate} alături de cel de refresh care preia cele mai recente valori ale senzorilor, fiecare având o secțiune dedicată funcționalității și a modului de utilizare.

Pe post de footer sunt alte două butoane care servesc pe post de notificări atunci când valoarea unui senzor scade sub o anumită limită, respectiv cel de informații personale ale creatorului licenței.

\subsection{Cărțile senzorilor}

Cărțile reprezintă principala sursă de informații pe care un utilizator o regăsește instant când accesează aplicația. Ele oferă date importante despre senzorul respectiv într-o formă ușor de înțeles și de citit rapid.

În prima parte putem observa numele de identificare a senzorului. Acesta îi este asignat manual atunci când placa Arduino este programată și trebuie neapărat să fie unic în toată rețeaua. 

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.5\textwidth]{3}
	\caption{Valorile unui modul}
	\label{fig:3}
\end{wrapfigure}

În cazul în care există multiple dispozitive cu același ID, stația de bază va crede că a primit două pachete de la același senzor, când defapt au fost trimise de către senzori care, foarte probabil, sunt programați să colecteze date diferite și astfel vor apărea discrepanțe vizibile între valorile trimise.

După, putem observa valoarea primită de către aplicație la data și ora respectivă. Odată ce este reîmprospătată pagina, dacă device-ul este conectat la rețea, telefonul va primi cea mai recentă măsurătoare din baza de date care primește informații noi odată la două secunde.

Și nu în ultimul rând, apare și locul fizic exact al senzorului, el fiind setat de către utilizator în aplicație. Inițial, acest câmp nu este vizibil deoarece senzorii nu au atașați un loc stabil, atașarea și schimbarea lui fiind făcute de către utilizator.

Când vine vorba despre device-urile dinamice, au o interfață asemănătoare, singura diferență fiind câmpul de adresă care deține IP-ul local al senzorului.

Atunci când acest widget este apăsat, utilizatorul va intra pe pagina senzorului respectiv, detaliile căreia vor fi prezentate ADAUGA REFERINTA.

\subsection{Locația senzorului}

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.4\textwidth]{2}
	\caption{Pop-up pentru locație}
	\label{fig:2}
\end{wrapfigure}

Cu un suport larg de diferite gesturi cu ajutorul clasei GestureDetector din Flutter, avem acces la o suită de detectări a mișcărilor degetetului care pot executa anumite funcții. În cazul aplicației, odată ce se ține apăsat pe un cartonaș, va apărea un dialog în care putem introduce locația fizică a senzorului.

Aceasta este salvată în memoria locală a telefonului cu ajutorul bibliotecii de gestionare a bazelor de date NoSQL (non-relaționale). Am ales biblioteca respectivă datorită performanței ridicate, simplitatea oferită și compatibilitatea cross-platform care este critică deoarece aplicația aceasta poate fi compilată pentru majoritatea device-urilor populare. 
\break

\subsection{Modul de securitate} 

\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.45\textwidth]{4}
	\caption{Interfață secure mode}
	\label{fig:4}
\end{wrapfigure}

În ultimii ani, numărul de furturi din locuințe se află pe un trend descrescător, conform informațiilor oferite de către Inspectoratul General al Poliției Române (\textbf{IGPR}). Așadar, în anul 2019 au fost înregistrate 22341 de furturi, iar în 2020 infracțiunile au ajuns la 18060, cu 19\% mai puține față de anul precedent. Chiar și în aceste circumstanțe, acest număr se datorează mentalității defensive în continuă dezvoltare și a sistemelor de alarmă care devin tot mai sofisticate. Am decis că introducerea unei astfel de abilități va contribui pozitiv la securizarea locuinței în care sistemul este instalat.

Modul de securitate se încadrează la categoria de bariere \emph{psihice} deoarece \emph{"descurajează infractorii sau detectează în faza incipientă o tentativă de pătrundere prin efracţie (sisteme de securitate perimetrală, antiefracţie, control al accesului sau sisteme de supraveghere şi înregistrare video)"}\footnote{\url{https://www.politiaromana.ro/ro/prevenire/furturi-din-locuinte}.}

Este recomandat ca, atunci când utilizatorul pleacă din incinta în care este instalată soluția smart home, să activeze modul de securitate. Fiecărui senzor îi poate fi atribuit o limită astfel încât orice valoare preluată  care scade sub acest prag (numit și \emph{Threshold}), va apărea sub forma unei notificări pe pagina de \emph{Logs}.

După ce este activat, utilizatorului îi este făcut prezent acest fapt prin schimbarea culorii de background. Valoarea acestui buton este salvată în baza de date Hive, împreună cu data și ora la care a fost schimbată. Aceasta din urmă va fi folosită la filtrarea alarmelor false.

Senzorii dinamici pot fi configurați astfel încât să se folosească de această valoare și din acest motiv, la fiecare schimbare a acestui buton, valoarea va fi postată pe ruta \textbf{https://andr3w.ddns.net/secure}, urmând să fie disponibilă tuturor device-urilor pentru a o putea citi.

\subsection{Butonul de refresh}

Funcționalitatea sa este intuitivă, întrucât apăsarea lui rezultă în re-împrospătarea valorilor din aplicație cu cele mai recente citiri ale tuturor senzorilor sistemului. Deoarece tot backend-ul este hostat pe un procesor cu un singur nucleu, am decis să implementez o metodă de \emph{caching} a datelor pentru sesiunea curentă. În acest mod salvăm serverul de la multe request-uri și economisim datele mobile.

Una din limitările sistemului este că informațiile afișate nu sunt actualizate constant. Acest lucru duce la discrepanțe între valorile pe care utilizatorul le vede și cele pe care senzorii le trimit. Vom vorbi despre aceasta în capitolul dedicat viziunii pe viitor.

\break

\section{Pagina senzorului static}

\begin{wrapfigure}{r}{0.3\textwidth}
	\includegraphics[width=0.4\textwidth]{5}
	\caption{Date avansate despre senzorul 01}
	\label{fig:5}
\end{wrapfigure}

Pe această rută se află informații și setări care contribuie la sensul de Smart home: componente ce lucrează împreună pentru a aduce utilizatorului un aport esențial de securitate.

AppBar-ul este populat cu un buton de setare a unei limite, valoare despre care am vorbit în secțiunea aceasta(ADAUGA SECUTIUNE MOD DE DECURITAET). Odată ce \emph{threshold} este setat (Figura 3.7.b), va fi salvată în baza de date locală, astfel ea persistând chiar și când restartăm aplicația. Ca să fie vizibilă utilizatorului, pe graficul de mai jos se va trasa o linie roșie (care nu există dacă nu avem o limită). Ca utilizare, limita va fi folosită la notificările de pe pagina de \emph{Logs} pentru a determina dacă o înregistrare trebuie arătată utilizatorului în caz că valoarea ei scade sub limita asignată.

În prim plan se află graficul care afișează evoluția ultimelor N înregistrări ale senzorului respectiv în funcție de data la care au fost colectate individual. Fiindcă sunt foarte multe puncte afișate, nu am putut include vizual și valorile lor, dar, utilizatorul o poate vedea, împreună cu data aferentă dacă apasă pe oricare punct (Figura 3.7.a). Pentru construcția sa, am decis să folosesc librăria \textbf{fl\_chart} datorită popularității și a documentației excelente. Este un grafic fluid deoarece odată ce se modifică valorile afișate, motorul fl\_chart creează o animație de tranziție de la informațiile vechi la cele noi.

Dedesubtul figurii apare un slider care setează numărul de puncte extrase de la server. A existat o problemă aici care îmi făcea un API call la fiecare schimbare de valoare, adică dacă de la 39 de puncte doresc să îmi afișeze 200, va face 200-39 = 161 request-uri către backend. Remediul a fost ca reîmprosătarea să fie făcută în funcția \textbf{onChangeEnd} care îmi dă libertatea să aleg orice valoare din interval atât timp cât degetul încă face contact cu ecranul. Atunci când am luat degetul de pe ecran, Flutter va face request-ul, evitând astfel un semi \emph{Denial of Service} pentru server.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.45\textwidth}
		\includegraphics[width=\textwidth]{6}
		\caption{Grafic}
		\label{fig:6}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\includegraphics[width=\textwidth]{7}
		\caption{Dialog limită}
		\label{fig:7}
	\end{subfigure}
	\caption{}
	\label{fig:all3}
\end{figure}

\section{Pagina senzorului dinamic}

\begin{wrapfigure}{r}{0.3\textwidth}
	\includegraphics[width=0.4\textwidth]{8}
	\caption{Informații și rutele senzorului dinamic}
	\label{fig:8}
\end{wrapfigure}

Modulele dinamice sunt destul de diferite față de cele statice, întrucât se conectează direct la rețeaua locală de Wi-Fi (fiindu-le asignat o adresă IP) și pot primi sau trimite comenzi la server sau la alte module dinamice. M-am decis să adaug acest tip de senzori datorită recomandării îndrumătorului licenței, domnul profesor Vidrașcu, o adiție ce se pliază perfect pe subiectul abordat în această teză: o soluție smart home.

După cum se poate observa, avem afișate datele despre senzor într-o manieră similară cu cea de la cei statici, diferența fiind IP-ul. Senzorii dinamici pot fi controlați de către utilizator și, în acest caz, este prin intermediul butoanelor ce apelează \emph{endpoint-urile} hostate pe ESP8266. Un endpoint reprezintă o locație specifică către care se pot face cereri HTTP (GET, POST, PUT, DELETE) pentru a accesa și manipula resursele unui serviciu. Serverul de pe ESP8266 își publică endpoint-urile la stația de bază care arată astfel: \textbf{http://192.168.0.101/turnOffLamp}.

Fiecare rută pe care o apelăm va instrui senzorul să execute diferite funcționalități care pot fi deduse din numele afișat pe buton.

\textbf{IntruderLampAlert} desemnează cum reacționează acest modul atunci când modul de securitate este activat și senzorul de mișcare emite un ”1” logic.

\section{Pagina de genereare de rapoarte}

În cazul în care utilizatorul este o victimă a unui jaf sau unei intruziuni în casă, este important să acționeze în mod corespunzător. Primul pas este să își asigure siguranța personală și să sune imediat la serviciile de urgență sau la poliție, încercând să nu intre în contact cu posibilii infractori sau să manipuleze evidențele rămase la fața locului, pentru a nu distruge potențiale probe. După anunțarea autorităților, trebuie făcută o inventariere a obiectelor pierdute și să fie extrase cât mai multe informații din ziua respectivă legate de incident.

Aplicația din această soluție ajută utlizatorul în cazul unui astfel de eveniment prin colectarea tuturor datelor senzorilor din casă, expunându-le în formă de PDF gata să fie oferite autorităților. Trebuie menționat faptul că senzorii au fost plasați specific în holul de la intrarea în apartamentul meu, pozitionați astfel încât orice persoană care intră va modifica starea modulelor.

Interfața (Figura 3.9.a) este alcătuită din cele două câmpuri ce permit introducerea timpului de început și cel de sfârșit. Acestea vor fi folosite de către server pentru a filtra toate înregistrările senzorilor, luându-le doar pe cele ce se încadrează în intervalul specificat. Cele două valori trebuie neapărat setate, întrucât butonul de \textbf{Generate report} nu va funcționa fiindcă nu știe unul din capetele intervalului sau chiar ambele. Odată apăsat, va trimite un POST request la stația de bază care îi va răspunde cu datele aferente. Utilizatorul este notificat de terminarea procesului printr-un pop-up în josul ecranului ce oferă și folderul în care a fost salvat.

Cu ajutorul librăriei \textbf{pdf} din cadrul SDK-ului Flutter, am reușit generarea documentului (Figura 3.9.b). Pe post de header, am specificat intervalul din care au fost extrase informațiile senzorilor și data la care a fost creat acest document. Footer-ul conține numele aplicației și deținătorul drepturilor licenței. În centrul atenției este un tabel ce conține, în ordine, numărul curent al înregistrării, adresa, data, ID-ul, tipul și valoarea senzorului. Acesta este extins pe multiple foi, cifra din partea de jos al ecranului desemnând numărul curent al paginii. Pentru raportul acesta avem un număr de 300 de înregistrări preluate în decursul a 5 minute.

Datele acestui document sunt valoroase și pot ajuta foarte mult investigatorii, crescând astfel șansele de a prinde intrușii. Asigurând proprietarii ce folosesc acest sistem cu un raport plin de informații, soluția de smart home propusă joacă un rol important în creșterea securității utilizatorului.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.43\textwidth}
		\centering
		\includegraphics[width=\textwidth]{9}
		\caption{Interfața paginii}
		\label{fig:9}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.43\textwidth}
		\centering
		\includegraphics[width=\textwidth]{10}
		\caption{PDF-ul generat}
		\label{fig:10}
	\end{subfigure}
	\caption{}
	\label{fig:all4}
\end{figure}
\break

\section{Senzori statici}

Acest tip de device-uri stă la baza metodei de coletare a informațiilor despre casa respectivă și cea de generare a unui raport cu toate valorile din baza de date în intervalul cerut.

Figura 3.3.a ne prezintă cum a fost creat un senzor static: un Arduino Nano care este cablat la senzorul de detectare a mișcării și modulul de transmitere a datelor. 

Senzorul are 3 pini care trebuie conectați la placa de dezvoltare: Ground (împământare), Vcc (+5V) și Out. Ultimul pin emite un 0 logic dacă nu a detectat niciun obiect și 1 logic dacă a detectat o persoană sau un animal. Acest lucru este posibil datorită faptului că este emisă căldură în formă de radiații infra-roșii care alimentează componenta \emph{piroelectrică} (Figura 3.3.b) amplasată dedesubtul unei lentile Fresnel ce ajută focusarea acestor raze pe lentila senzorului. Modulul are încorporat două potențiometre: unul pentru reglarea razei de acțiune (până în 5 metri), iar celălalt pentru reglarea timpului de schimbare a valorii detectate (între 0.3 - 300 secunde). 

Odată alimentat la 5V, microcontroller-ul începe colectarea de date odată la două secunde. După ce acest interval a trecut, va fi creat un pachet ce conține ID-ul și tipul modulului, valoarea și data la care a fost făcută măsurătoarea. 

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.85\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{static}
		\caption{Arduino Nano + senzor de mișcare + modul transmisie}
		\label{fig:static}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.8\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{pir}
		\caption{Componenta piroelectrică}
		\label{fig:pir}
	\end{subfigure}
	\caption{}
	\label{fig:all2}
\end{figure}
\break

Transmiterea și primirea acestor pachete va fi detaliată în secțiunea despre placa NRF24L01 unde vom vorbi de banda 2.4GHz, structura unui pachet de date și RF24Network. 

\section{Senzori dinamici}

Senzorii dinamici dețin o complexitate mai ridicată față de tipul anterior prezentat datorită faptului că pot trimite și primi date simultan de la server, făcându-i să pară că folosesc o conexiune \emph{full duplex}. Din cauza faptului că legătura dintre server și senzor se face prin intermediul protocolului Wifi, înseamnă că această legătură este mai degrabă \emph{half duplex}, schimbul de date realizându-se prin alternarea transmițătorului și receptorului, iar dispozitivele trebuie să respecte un anumit protocol de acces pentru evitarea coliziunilor și interferențelor cu alte dispozitive. CITAT

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{dinamic}
	\caption{ESP8266 + modul releu alimentat la 220V}
	\label{fig:dinamic}
\end{figure}